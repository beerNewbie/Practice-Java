## **JVM**参数与volatile

### 1. JVM工具

#### 1.1 *jps：JVM进程状态工具*

- [ ] **列出正在运行的JVM进程，并返回进程ID**
- [ ] **jps -l  :   输出主类全名，返回进程ID**

#### 1.2 jstat：JVM统计信息显示工具

- [ ] 显示本地或远程JVM中标类装载、内存、垃圾回收等数据。
- [ ] jstat -gcutil PID  :   显示垃圾回收信息

#### 1.3 jinfo：JVM配置信息查看工具

- [ ] jinfo -flags PID

#### 1.4 *jmap：内存映像工具（查看java堆具体信息）*

- [ ] **jmap用于生成堆转储快照（堆的快照）**
- [ ] **jmap -heap PID** ：显示JVM堆具体信息
- [ ] **jmap -histo PID** ：显示JVM中对象的统计信息

#### 1.5 jhat：heap文件的分析工具

- [ ] jhat heap文件路径

#### 1.6 *jstack：Java堆栈跟踪工具*

- [ ] **jstack生成当前JVM线程的快照。**
- [ ] **可用于定位线程出现长时间停顿的原因，如线程死锁、死循环等问题**

### 2. Java内存模型（JMM）-基于线程的内存模型

- [ ] JMM定义的主要目的为了定义程序中各个变量的访问规则（JVM如何将变量从内存中取出以及如何再将变量再写回内存等细节）。此处的变量包括实例字段、静态字段与数组元素等

#### 2.1 主内存（所有线程共有）与工作内存（每个线程独有）

- [ ] **JMM规定所有变量必须存储主内存中。每条线程都有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读取主内存中的变量。不同线程之间无法直接访问彼此的工作内存变量，线程变量值的传递均需要通过主内存来完成。**

#### 2.2 内存间交互操作

#### 2.3 JMM内存三大特性

- [ ] **原子性：基本数据类型的访问读写是具备原子性的（如：int i = 0;是   i = 3;是   i++;不是    i--;不是），如若需要更大范围的原子性，需要内建锁或lock体系支持（如i++; i--;等操作）**
- [ ] **一致性：当一个线程修改了共享变量的值，其他线程能立即得知此修改。volatile、final、synchronized可以实现可见性**
- [ ] **有序性：若在本线程内观察，所有操作都是有序的；若在线程之外观察另外一个线程，所有操作都是无序的。JMM具备先天的有序性，即无需通过任何手段就能保证有序性，称为JMM的==happens-before原则（先行发生原则）==。若两个操作的次序无法从happens-before中推导出来，则无法保证亲有序性，JVM可以任意对其排序。**
- [ ] **要想并发程序的正确执行，必须同时保证原子性、可见性及有序性**。只要有任意一个没有被保证，就有可能导致程序运行不正确。

#### 2.4 volatile变量的特殊规则

##### 2.4.1 第一：保证此变量对所有线程的可见性

- [ ] **当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的，普通变量无法做到可见性（因为根据happens-before原则：volatile变量规则：对于一个变量的写操作先行发生于对这个变量的读操作）**
- [ ] **volatile变量在各个线程中是一致的，但volatile变量的 运算在并发下一样是不安全的。Java中运算操作并非原子性，必须结合内建锁或lock体系来约束。**
- [ ] **由于volatile变量只保持可见性，在不符合一下两条规则的场景下，仍需要使用加锁来保证原子性：**
  - **运算结果不依赖当前变量的值，或者能够确保只有单一的线程修改变量值。**
  - **变量不需要与其他的状态变量共同参与不变约束。**
- [ ] **并发场景下对于类似i++操作如何正确保证结果：**
  - **1.加锁**
  - **2.使用原子类（java.util.atomic包下的所有类一定是原子类--内部使用CAS保证原子性）**

##### 2.4.2 禁止指令重排

- [ ] **当程序执行到volatile变量的读或写操作时，在其前面的操作肯定全部执行完毕且结果已经对后面的操作可见，在其后面的操作肯定还没有执行。**
- [ ] **在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能提前执行。**

### 3. 懒汉式单例的线程安全

```java
class Singleton {
	//加volatile防止多线程情况下指令重排出现空指针异常
	private static volatile Singleton singleton;
	private Singleton() {}
    public String getStr() {
        return str;
    }
	public static Singleton getInstance() {
		//首先判断singleton是否为空
		if (singleton == null) {
			//加锁
			synchronized(Singleton.class) {
				//不判断就在多线程情况下可能new多次
				if (singleton == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
```

